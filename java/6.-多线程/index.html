<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="VarKai" />
	
	
	
	<title>六、多线程 ｜ ZOZO</title>
	
    
    
    <meta name="description" content="实现多线程 线程同步 线程协作 实现多线程 进程（Process） 进程：是正在运行的程序。 是系统进行资源分配和调用的独立单位。 每一个进程都有它自己的内存空间和系统资源。 线程（Thread） 线程：是进程中的单个" />
    

    
    
    <meta name="keywords" content="Hugo, theme, zozo" />
    

	
    
    <link rel="shortcut icon" href="https://211307.github.io/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://211307.github.io/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://211307.github.io/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://211307.github.io/css/highlight.css" />

    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">主页</a>
            </li>
            
            <li>
                <a href="/tags/">标签</a>
            </li>
            
            <li>
                <a href="/about/">关于</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://211307.github.io/">
                    <span>ZOZO</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title">中二少年</p>
            <div class="my_socials">
                
                
                <a href="%20" title="facebook" target="_blank"><i class="ri-facebook-fill"></i></a>
                
                
                
                <a href="%20" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                
                <a href="%20" title="instagram" target="_blank"><i class="ri-instagram-fill"></i></a>
                
                
                
                <a href="%20" title="twitter" target="_blank"><i class="ri-twitter-fill"></i></a>
                
                
                
                <a href="%20" title="weibo" target="_blank"><i class="ri-weibo-fill"></i></a>
                
                
                <a href="https://211307.github.io/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/java/6.-%E5%A4%9A%E7%BA%BF%E7%A8%8B/'>六、多线程</a></h2>
                        <span class="date">2020.06.24</span>
                    </div>
                    <div class="post_content markdown"><!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B">实现多线程</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C">线程协作</a></li>
</ul>
<!-- /code_chunk_output -->
<hr>
<h2 id="实现多线程">实现多线程</h2>
<hr>
<ol>
<li>
<p><strong>进程（Process）</strong></p>
<ul>
<li>进程：是正在运行的程序。
<ul>
<li>是系统进行资源分配和调用的独立单位。</li>
<li>每一个进程都有它自己的内存空间和系统资源。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程（Thread）</strong></p>
<ul>
<li>线程：是进程中的单个顺序控制流，是一条执行路径。
<ul>
<li>单线程：一个进程如果只有一条执行路径，则成为单线程程序。</li>
<li>一个进程如果有多条执行路径，则成为多线程程序。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程的状态</strong></p>
<ul>
<li>五大状态：
<img src="%E5%9B%BE%E5%BA%93/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81.png" alt="线程生命周期表" title="线程生命周期表"></li>
</ul>
</li>
<li>
<p><strong>线程创建</strong></p>
<ol>
<li>
<p><strong>继承 Thread 类</strong></p>
<ol>
<li>
<p>过程：</p>
<ul>
<li>定义一个类 MyThread 继承 Thread 类</li>
<li>在 MyThread 类中重写 run() 方法，编写线程执行体</li>
<li>在 main 方法中 new MyThread 类的对象</li>
<li>使用 start() 启动线程</li>
</ul>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建 线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="n">Thread</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span> <span class="n">编写线程执行体</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 调用
</span><span class="c1"></span><span class="n">MyThread</span> <span class="n">对象名</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyThread</span><span class="o">();</span>
<span class="n">对象名</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></li>
<li>
<p>注意：</p>
</li>
</ol>
<ul>
<li>线程开启不一定立即执行由 CPU 调度。</li>
<li>run() 和 start() 方法的区别：
<ul>
<li>run()：封装线程执行的代码。直接调用，相当于普通方法的调用。</li>
<li>start()：启动线程；开辟一条新线程，调用 run() 方法。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>实现 Runnable 接口</strong></p>
<ol>
<li>
<p>过程：</p>
<ul>
<li>定义一个类 MyThread 实现 Runnable 接口</li>
<li>在 MyRunnable 类中重写 run() 方法，编写线程执行体</li>
<li>在 main 方法中创建 MyRunnable 类的对象</li>
<li>创建 Thread 类对象，把 MyRunnable 对象作为构造方法的参数</li>
<li>使用 start() 启动线程</li>
</ul>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建 线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">implements</span> <span class="n">Runable</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span> <span class="n">编写线程执行体</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 调用
</span><span class="c1"></span><span class="n">MyRunnable</span> <span class="n">对象名</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyRunnable</span><span class="o">();</span>
<span class="n">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">对象名</span><span class="o">,</span><span class="s">&#34;线程名字&#34;</span><span class="o">);</span>  <span class="c1">// 线程名字可以不写。
</span><span class="c1"></span><span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="c1">// 省略代码
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">对象名</span><span class="o">,</span><span class="s">&#34;线程名字&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>  <span class="c1">// 可以让多个线程使用同一个对象名。
</span></code></pre></div></li>
<li>
<p>Runnable 接口的好处：</p>
</li>
</ol>
<ul>
<li>避免了 java 单继承的局限性。</li>
<li>方便同一个对象被多个线程使用，把线程和程序的代码数据有效分离，较好的体现了面向对象的设计思想。</li>
</ul>
</li>
<li>
<p><strong>实现 Callable 接口</strong></p>
<ul>
<li>
<p>步骤：</p>
<ul>
<li>实现 Callable 接口，需要返回值类型</li>
<li>重写 call 方法，需要抛出异常</li>
<li>创建目标对象</li>
<li>创建执行服务：<code>ExecutorService ser = Executors.newFixedThreadPool(1);</code></li>
<li>提交执行：<code>Future&lt;Boolean&gt; result1 = ser.submit(t1);</code></li>
<li>获取结果：<code>boolean r1= result1.get();</code></li>
<li>关闭服务：<code>ser.shutdownNow();</code></li>
</ul>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 导包
</span><span class="c1"></span><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="c1">// 实现 Callable 接口，并提供返回值类型
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="kd">implements</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// 重写 call 方法
</span><span class="c1"></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我爱&#34;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// 创建 main 方法
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
      <span class="n">s</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">s</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
      <span class="c1">// 创建目标对象
</span><span class="c1"></span>      <span class="n">Name</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Name</span><span class="o">();</span>
      <span class="c1">// 创建执行服务
</span><span class="c1"></span>      <span class="n">ExecutorService</span> <span class="n">ser</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>  <span class="c1">// 输入线程数量
</span><span class="c1"></span>      <span class="c1">// 提交执行
</span><span class="c1"></span>      <span class="n">Future</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">name</span><span class="o">);</span> <span class="c1">// 线程对象名
</span><span class="c1"></span>      <span class="c1">// 获取结果
</span><span class="c1"></span>      <span class="n">String</span> <span class="n">r1</span><span class="o">=</span> <span class="n">result1</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
      <span class="c1">// 关闭服务
</span><span class="c1"></span>      <span class="n">ser</span><span class="o">.</span><span class="na">shutdownNow</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p>callable 的好处</p>
<ul>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>静态代理</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 静态代理模式总结：
</span><span class="c1"></span>  <span class="c1">// 真实对象和代理对象都要实现同一个接口
</span><span class="c1"></span>  <span class="c1">// 代理对象要代理真实角色
</span><span class="c1">// 好处
</span><span class="c1"></span>  <span class="c1">// 代理对象可以做很多真实对象做不了的事情
</span><span class="c1"></span>  <span class="c1">// 真实对象可以专心做自己的事情
</span><span class="c1">// 注意
</span><span class="c1"></span>  <span class="c1">// 静态代理就是线程底部的实现原理
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">WeddingCompany</span> <span class="n">weddingCompany</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeddingCompany</span><span class="o">(</span><span class="k">new</span> <span class="n">You</span><span class="o">());</span>  <span class="c1">// 通过 new You 获取 You 方法的地址
</span><span class="c1"></span>        <span class="n">weddingCompany</span><span class="o">.</span><span class="na">HappyMarry</span><span class="o">();</span>

        <span class="c1">// 精简版
</span><span class="c1"></span>        <span class="k">new</span> <span class="n">WeddingCompany</span><span class="o">(</span><span class="k">new</span> <span class="n">You</span><span class="o">()).</span><span class="na">HappyMarry</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 接口
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">Marry</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">HappyMarry</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 真实角色
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">You</span> <span class="kd">implements</span> <span class="n">Marry</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">HappyMarry</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;秦老师要结婚了&#34;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">WW</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我要哭&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 代理角色
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">WeddingCompany</span> <span class="kd">implements</span> <span class="n">Marry</span><span class="o">{</span>
    <span class="c1">// 目标对象
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Marry</span> <span class="n">target</span><span class="o">;</span><span class="c1">// 保存 You 类 的地址
</span><span class="c1"></span>    <span class="c1">// 构造方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">WeddingCompany</span><span class="o">(</span><span class="n">Marry</span> <span class="n">target</span><span class="o">){</span>
        <span class="c1">// 把 You 方法的地址赋值到 target
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">target</span><span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">HappyMarry</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">before</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">HappyMarry</span><span class="o">();</span>   <span class="c1">// 通过 target 找到 真实对象 You
</span><span class="c1"></span>        <span class="n">after</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;结婚之后，收尾款&#34;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;结婚之前，布置现场&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p><strong>Lamda 表达式</strong></p>
<ul>
<li>
<p>概述：</p>
<ul>
<li>避免匿名内部类定义过多。</li>
<li>可以让你的代码看起来很简洁。</li>
<li>去掉了一堆没有意义的代码，只留下核心的逻辑。</li>
<li>理解 Functional Interface（函数式接口）是学习 Java8 Lambda 表达式的关键所在。</li>
<li>Lamda 属于函数式编程的概念。</li>
<li>函数式接口的定义：
<ul>
<li>任何接口，如果只包含 <strong>唯一</strong> 一个抽象方法，那么它就是一个函数式接口。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建函数式接口
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">接口类名</span><span class="o">{</span>
  <span class="kt">void</span> <span class="nf">lambda</span><span class="o">(</span><span class="n">数据类型</span> <span class="n">变量名</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 使用 Lamda 调用函数接口
</span><span class="c1"></span><span class="n">接口类名</span> <span class="n">对象名</span> <span class="o">=</span> <span class="n">变量名</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;我爱中国5&#34;</span><span class="o">);};</span>
<span class="c1">// 调用 Lambda
</span><span class="c1"></span><span class="n">对象名</span><span class="o">.</span><span class="na">lambda</span><span class="o">;</span>

<span class="c1">// 简化线程代码
</span><span class="c1"></span><span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;aaa&#34;</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></li>
<li>
<p>总结：</p>
<ul>
<li>对于函数式接口，我们可以通过 Lambda 表达式来创建该接口的对象。</li>
<li>对于只有一行代码可以省略花括号，多行代码要使用代码块包裹。</li>
<li>前提是接口必须是 <strong>函数式接口</strong>。</li>
<li>多个参数也可以去掉参数类型，但要去掉必须都去掉，多个参数必须加上括号。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程停止</strong></p>
<ul>
<li>不推荐使用 JDK 提供的 stop()、destroy() 方法。[已废弃]</li>
<li>推荐线程自己停止下来</li>
<li>建议使用一个标识位进行终止变量 当 flag = false，则终止线程运行。
<ul>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
  <span class="c1">// 1. 线程中定义线程体使用的标识
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
      <span class="c1">// 2. 线程体使用该标识
</span><span class="c1"></span>      <span class="k">while</span> <span class="o">(</span><span class="n">flag</span><span class="o">){</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;run...Thread &#34;</span><span class="o">+</span><span class="n">i</span><span class="o">++);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 3. 对外提供方法改变标识
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span>  <span class="nf">stop</span><span class="o">(){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Name</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Name</span><span class="o">();</span>
      <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;main&#34;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="n">10</span><span class="o">){</span>
              <span class="n">name</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
              <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;线程终止了&#34;</span><span class="o">);</span>
          <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程名称的设置和获取</strong></p>
<ul>
<li>Thread 类中设置和获取线程名称的方法：
<ul>
<li><strong>设置线程名称</strong>
<ul>
<li><code>void setName(String name)</code>：将此线程的名称更改为等于参数 name
<ul>
<li>通过 new 类的对象名直接调用。</li>
</ul>
</li>
<li>通过构造方法重写线程名称：
<ul>
<li><code>类名 (String name){super(name);}</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>获取线程名称</strong>
<ul>
<li><code>String getName()</code>：返回此线程的名称
<ul>
<li>通过 new 类的对象名直接调用。</li>
</ul>
</li>
<li><code>public static Thread currentThread​()</code>：返回对当前正在执行的线程对象的引用(返回当前线程的名字)。
<ul>
<li>格式：<code>System.out.println(Thread.currentThread().getName());</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程优先级</strong></p>
<ul>
<li>
<p>线程有两种调度模型</p>
<ul>
<li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片。</li>
<li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 的时间片相对多一些。</li>
<li>java 使用的是抢占式调度模型。</li>
</ul>
</li>
<li>
<p>Thread 类中设置线程优先级的方法：</p>
<ul>
<li>
<p><code>public final void setPriority​(int newPriority)</code>：更改此线程的优先级。</p>
</li>
<li>
<p>线程范围数据：</p>
<ul>
<li>最高值是：10</li>
<li>最小值：1</li>
<li>默认值：5</li>
<li>注意：线程优先级仅仅只是表示 线程获取 CPU 时间片几率高</li>
</ul>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">对象名</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="n">数值</span><span class="o">);</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>Thread 类中获取线程优先级的方法：</p>
<ul>
<li>
<p><code>public final int getPriority​()</code>：返回此线程的优先级。</p>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">对象名</span><span class="o">.</span><span class="na">getPriority</span><span class="o">();</span>
<span class="c1">// 查看当前线程优先级
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&#34;--&gt;&#34;</span><span class="o">+</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getPriority</span><span class="o">());</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程休眠</strong></p>
<ul>
<li><code>static void sleep(long millis)</code>：指定当前线程阻塞的毫秒;</li>
<li>sleep 存在异常 InterruptedException;</li>
<li>sleep 时间到达后线程进入就绪状态；</li>
<li>sleep 可以模拟网络延时，倒计时等。
<ul>
<li>模拟网络延时可以放大问题的发生性。</li>
</ul>
</li>
<li>每一个对象都有一个锁，sleep 不会释放锁;
<ul>
<li>
<p>格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
  <span class="k">try</span> <span class="o">{</span>
      <span class="c1">// 设置 线程 停留时间
</span><span class="c1"></span>      <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程礼让</strong></p>
<ul>
<li>
<p>礼让线程，让当前正在执行的线程暂停，但不阻塞。</p>
</li>
<li>
<p>将线程从运行状态转为就绪状态。</p>
</li>
<li>
<p>让 CPU 重新调整，礼让不一定成功！看 cpu 心情。</p>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 创建 类对象
</span><span class="c1"></span>    <span class="n">NA</span> <span class="n">na</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NA</span><span class="o">();</span>
    <span class="c1">// 调用线程
</span><span class="c1"></span>    <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">na</span><span class="o">,</span> <span class="s">&#34;a&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">na</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 实现 Runnable 接口
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">NA</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&#34;线程开始&#34;</span><span class="o">);</span>
      <span class="c1">// 线程礼让
</span><span class="c1"></span>      <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&#34;线程结束&#34;</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>线程强制执行</strong></p>
<ul>
<li><code>void join()</code>：待此线程执行完毕，在执行其它线程。
<ul>
<li>
<p>格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">对象名</span><span class="o">.</span><span class="na">jojin</span><span class="o">();</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>观测线程状态</strong></p>
<ul>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;...........&#34;</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 观察状态
</span><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">State</span> <span class="n">state</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">);</span> <span class="c1">// NEW
</span><span class="c1"></span>
        <span class="c1">// 观察启动后
</span><span class="c1"></span>        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动线程
</span><span class="c1"></span>        <span class="n">state</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">);</span> <span class="c1">// Run
</span><span class="c1"></span>
        <span class="k">while</span><span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">State</span><span class="o">.</span><span class="na">TERMINATED</span><span class="o">){</span><span class="c1">// 只要线程不终止，就一直输出状态。
</span><span class="c1"></span>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">100</span><span class="o">);</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span> <span class="c1">// 更新线程状态
</span><span class="c1"></span>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">state</span><span class="o">);</span> <span class="c1">// 输出状态
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>守护线程</strong></p>
<ul>
<li>线程分为 <strong>用户线程</strong> 和 <strong>守护线程</strong>。</li>
<li>虚拟机必须确保用户线程执行完毕。</li>
<li>虚拟机不用等待守护线程执行完毕。
<ul>
<li>如：后台记录操作日志，监控内存，垃圾回收等待&hellip;</li>
</ul>
</li>
<li><code>void setDaemon(boolean on)</code>：将此线程标记为守护线程，当运行的线程都是守护线程时，java 虚拟机将退出。
<ul>
<li>
<p>false 表示用户线程。</p>
</li>
<li>
<p>true 表示守护线程。</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">对象名</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="c1">// 测试代码
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  <span class="o">{</span>
        <span class="n">God</span> <span class="n">god</span> <span class="o">=</span> <span class="k">new</span> <span class="n">God</span><span class="o">();</span>
        <span class="n">You</span> <span class="n">you</span> <span class="o">=</span> <span class="k">new</span> <span class="n">You</span><span class="o">();</span>
        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">god</span><span class="o">);</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 把上帝类设置为 守护线程
</span><span class="c1"></span>        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动上帝类
</span><span class="c1"></span>        <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">you</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 上帝
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">God</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;上帝守护着你&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 你
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">You</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">35600</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;活着&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;=====goodbye! world!=======&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程同步">线程同步</h2>
<hr>
<ol>
<li>
<p><strong>并发</strong></p>
<ul>
<li>并发：同一个对象 被 多个线程同时操作</li>
</ul>
</li>
<li>
<p><strong>线程同步</strong></p>
<ul>
<li>线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个 <strong>对象的等待池</strong> 形成队列，等待前面线程使用完毕，下一个线程再使用。</li>
<li>线程同步形成条件：队列 + 锁</li>
<li>线程同步 的锁机制 synchronized（关键字）。</li>
</ul>
</li>
<li>
<p><strong>同步方法</strong></p>
<ul>
<li>
<p><strong>同步监视器的执行过程</strong>：</p>
<ol>
<li>第一个线程访问，锁定同步监视器，执行其中代码。</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问。</li>
<li>第一个线程访问完毕，解锁同步监视器。</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ol>
</li>
<li>
<p><strong>同步代码块</strong>：synchronized(Obj){ }</p>
<ul>
<li>锁多条语句操作共享数据，可以使用同步代码块实现。</li>
<li>Obj 称之为 <strong>同步监视器</strong>
<ul>
<li>
<p>Obj 可以是任何对象，锁的是需要增删改查的对象，但是推荐使用共享资源作为同步监视器</p>
</li>
<li>
<p>格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">synchronized</span><span class="o">(</span><span class="n">任意对象</span><span class="o">){</span>
    <span class="n">多条语句操作共享数据的代码</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// 建议格式：
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="o">{....}</span>
  <span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>同步方法</strong>：就是把 <code>synchronized</code> 关键字加到方法上。</p>
<ul>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器是 this，就是这个对象本身，或者是 class。</li>
<li>格式：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
  <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{....}</span>
<span class="o">}</span>
<span class="n">修饰符</span> <span class="kd">synchronized</span> <span class="n">返回值类型</span> <span class="nf">方法名</span><span class="o">(</span><span class="n">方法参数</span><span class="o">){</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p><strong>静态同步方法</strong>：</p>
<ul>
<li>
<p>同步静态方法锁对象是：<code>类名.class</code></p>
</li>
<li>
<p>代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
  <span class="kd">synchronized</span> <span class="o">(</span><span class="n">类名</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{....}</span>
<span class="o">}</span>
<span class="n">修饰符</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">方法名</span><span class="o">(){</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>同步的好处和弊端</strong>：</p>
<ul>
<li>好处：解决了多线程的数据安全问题。</li>
<li>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>线程安全的类</strong></p>
<ul>
<li><strong><code>StringBuffer</code></strong>
<ul>
<li>线程安全，可变的字符序列。</li>
<li>从版本 JDK5 开始，被 StringBuilder 替代。通常使用 StringBuilder 类，因为它支持所有相同的操作，但它更快，因为它不执行同步。</li>
<li>格式：<code>StringBuffer 对象名 = new StringBuffer()</code></li>
</ul>
</li>
<li><strong><code>Vector</code></strong>
<ul>
<li>从 java2 平台 v1.2 开始，该类改进了 List 接口，使其成为 Java Collections Framework 的成员。与新的集合实现不同，Vector 被同步。如果不需要线程安全的实现，建议使用 ArrayList 替代 Vector。</li>
<li>格式：<code>Vector&lt;E&gt; 对象名 = new Vector&lt;E&gt;();</code></li>
</ul>
</li>
<li><strong><code>Hashtable</code></strong>
<ul>
<li>该类实现了一个哈希表，它将键映射到值。任何非 null 对象都可以用作键或值。</li>
<li>从 java2 平台 v1.2 开始，该类进行了改进，实现了 Map 接口，使其成为 Java Collections Framework 的成员。与新的集合实现不同，Hashtable 被同步。如果不需要线程安全的实现，建议使用 HashMap 代替 Hashtable。</li>
<li>格式：<code>Hashtable&lt;E,E&gt; 对象名 = new Hashtable&lt;E,E&gt;();</code></li>
</ul>
</li>
<li><strong>CopyOnWriteArrayList</strong> 类
<ul>
<li>JUC 并发包里的 ArrayList 安全类。</li>
<li>线程安全类，官方写的 ArrayList 类的线程安全类。</li>
<li>在 concurrent 包下。</li>
</ul>
</li>
<li><strong>把不安全的类转换成安全的类</strong>：
<ul>
<li>格式：<code>List&lt;String&gt; 对象名 = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>死锁</strong></p>
<ul>
<li>
<p><strong>死锁</strong>：多个线程互相抱着对方需要的资源，然后形成僵持。</p>
</li>
<li>
<p><strong>产生死锁的四个必要条件</strong>：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞是，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
<li>只要一上一个条件或多个条件不成立，就可以避免死锁。</li>
</ol>
</li>
<li>
<p>死锁代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Mekeup</span> <span class="n">g1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Mekeup</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="s">&#34;灰姑娘&#34;</span><span class="o">);</span>
        <span class="n">Mekeup</span> <span class="n">g2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Mekeup</span><span class="o">(</span><span class="n">1</span><span class="o">,</span><span class="s">&#34;白雪公主&#34;</span><span class="o">);</span>
        <span class="n">g1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">g2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 口红
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Lipstick</span><span class="o">{</span>
<span class="o">}</span>
<span class="c1">// 镜子
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Mirror</span><span class="o">{</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Mekeup</span> <span class="kd">extends</span> <span class="n">Thread</span><span class="o">{</span>
    <span class="c1">// 确保资源只有一份
</span><span class="c1"></span>    <span class="kd">static</span> <span class="n">Lipstick</span> <span class="n">lipstick</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lipstick</span><span class="o">();</span>
    <span class="kd">static</span> <span class="n">Mirror</span> <span class="n">mirror</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Mirror</span><span class="o">();</span>
    <span class="c1">// 选择
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">choice</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">girName</span><span class="o">;</span>
    <span class="n">Mekeup</span><span class="o">(</span><span class="kt">int</span> <span class="n">choice</span><span class="o">,</span><span class="n">String</span> <span class="n">girName</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">choice</span><span class="o">=</span><span class="n">choice</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">girName</span><span class="o">=</span><span class="n">girName</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
        <span class="n">makeup</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeup</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">choice</span> <span class="o">==</span><span class="n">0</span> <span class="o">){</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lipstick</span><span class="o">){</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">girName</span><span class="o">+</span><span class="s">&#34;获得口红的锁&#34;</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 延时
</span><span class="c1"></span>                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">100</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mirror</span><span class="o">){</span>  <span class="c1">// 只要不让这个锁在 上个锁的代码块中就可以解决死锁问题。
</span><span class="c1"></span>                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">girName</span><span class="o">+</span><span class="s">&#34;获得镜子的锁&#34;</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="o">}</span>


        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mirror</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">girName</span> <span class="o">+</span> <span class="s">&#34;获得镜子的锁&#34;</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 延时
</span><span class="c1"></span>                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">200</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lipstick</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">girName</span> <span class="o">+</span> <span class="s">&#34;获得口红的锁&#34;</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Lock 锁</strong></p>
<ul>
<li>java 为了让我们更清晰的表达锁和释放锁，jdk5 以后提供了一个新的锁对象 Lock
<ul>
<li>
<p>Lock 实现提供了比使用 synchronized 方法和语句可以获得更广泛的锁定操作。</p>
</li>
<li>
<p>Lock 中提供了获得锁和释放锁的方法：</p>
<ul>
<li><code>void lock()</code>：获得锁</li>
<li><code>void unlock()</code>：释放锁</li>
<li>代码：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 导包
</span><span class="c1"></span><span class="kn">import</span> <span class="nn">java.util.concurrent.locks.*</span><span class="o">;</span>
<span class="c1">// 创建 Lock 对象
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
  <span class="c1">// 加锁
</span><span class="c1"></span>  <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>  <span class="c1">// lock.lock(); 放到 try{} 里面会导致弹出异常时，无法加锁。
</span><span class="c1"></span>  <span class="c1">// 防止代码出错 不能解锁
</span><span class="c1"></span>  <span class="k">try</span><span class="o">{</span>
    <span class="n">被解锁的代码</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="c1">// 解锁；
</span><span class="c1"></span>    <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></li>
<li>
<p>Lock 是接口不能直接实例化，这里采用它的实现类 ReentrantLock 来实例化</p>
</li>
<li>
<p>ReentrantLock 的构造方法：</p>
<ul>
<li><code>ReentrantLock()</code>：创建一个 ReentrantLock 的实例化</li>
</ul>
</li>
<li>
<p>synchronized 与 Lock 的对比</p>
<ul>
<li>Lock 是显式锁（需要手动开启和关闭锁）synchronized 是隐式锁，出了作用域自动释放。</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁。</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序：
<ul>
<li>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程协作">线程协作</h2>
<hr>
<ol>
<li><strong>生产者消费者模式</strong>
<ul>
<li>生产者消费者问题，只要包含两类线程：
<ul>
<li>一类是生产者线程用于生产数据</li>
<li>一类是消费者线程用于消费数据</li>
</ul>
</li>
<li>生产者和消费者的关系：
<ul>
<li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</li>
<li>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</li>
</ul>
</li>
<li>java 提供了几个方法解决线程之间的通信问题
<ul>
<li><code>void wait()</code>：导致当前线程等待，直到另一个线程调用该对象的 notify() 方法或 notifyAll() 方法。</li>
<li><code>wait(long timeout)</code>：指定等待的毫秒数。</li>
<li><code>void notify()</code>：唤醒正在等待对象监视器的单个线程。</li>
<li><code>void notifyAll()</code>：唤醒正在等待对象监视器的所有线程。</li>
<li>注意：
<ul>
<li>均是 Object 类的方法，都只能在同步方法或同步代码块中使用，否则会抛出异常 IIIegalMonitorStateException</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://211307.github.io/tags/java/">java</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                <div class="doc_comments"></div>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span>人不中二，往少年</span>
    </div>
</footer>
    <script src="https://211307.github.io/js/jquery-3.5.1.min.js"></script>
<link href="https://211307.github.io/css/fancybox.min.css" rel="stylesheet">
<script src="https://211307.github.io/js/fancybox.min.js"></script>
<script src="https://211307.github.io/js/zozo.js"></script>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\[\[', '\]\]']],
                processEscapes: true,
                processEnvironments: true,
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                TeX: {
                    equationNumbers: { autoNumber: "AMS" },
                    extensions: ["AMSmath.js", "AMSsymbols.js"]
                }
            }
        });

        MathJax.Hub.Queue(function () {
            
            
            
            var all = MathJax.Hub.getAllJax(), i;
            for (i = 0; i < all.length; i += 1) {
                all[i].SourceElement().parentNode.className += ' has-jax';
            }
        });
    </script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style>



</body>

</html>